///// 3d surface ///////

int count_digits(int arg);
void PLOutput(const char *driver, int x_ratio, int y_ratio, const char *filename);
static void cmap1_init(int);

#define XPTS    50          // Data points in x
#define YPTS    50             // Data points in y


int main(int argc, char *argv[]) {

	PLOutput("ntk", 70, 70, "ciao.svg");

	PLFLT    *x, *y, **z;
	PLFLT    dx = 20 / (PLFLT)(XPTS - 1);
	PLFLT    dy = 20 / (PLFLT)(YPTS - 1);
	PLFLT    zmin, zmax;

	// Parse and process command line arguments 
	// Initialize plplot

	plinit();
	x = (PLFLT *)calloc(XPTS, sizeof(PLFLT));
	y = (PLFLT *)calloc(YPTS, sizeof(PLFLT));
	plAlloc2dGrid(&z, XPTS, YPTS);

	for (int i = 0; i < XPTS; i++) {
		x[i] = -10 + (PLFLT)i * dx;
	}

	for (int j = 0; j < YPTS; j++) {
		y[j] = -10 + (PLFLT)j * dy;
	}

	for (int i = 0; i < XPTS; i++) {
		for (int j = 0; j < YPTS; j++) {
			z[i][j] = pow(y[j], 2) + pow(x[i], 2);
			//sign(xx) * atan(xx * 80) / 6 * sign(-yy - xx + 1) * sign(-yy + xx + 1) * 5 - 1.01;
		}
	}

	plMinMax2dGrid((PLFLT_MATRIX)z, XPTS, YPTS, &zmax, &zmin);

	c_pllightsource(1., 1., 1.);

	pladv(0);
	plvpor(0.0, 1.0, 0.0, 0.9);
	plwind(-1.0, 1.0, -0.9, 1.1);

	plcol0(3);
	plmtex("t", 1.0, 0.5, 0.5, "Ripple");

	plcol0(1);
	plw3d(1.0, 1.0, 1.0, x[0], x[XPTS-1], y[0], y[YPTS-1], zmin, zmax, 40, 45);

	plbox3("bnstu", "x axis", 0.0, 0,
			"bnstu", "y axis", 0.0, 0,
			"bcdmnstuv", "z axis", 0.0, 0);

	cmap1_init(0);
	plsurf3d(x, y, (PLFLT_MATRIX)z, XPTS, YPTS, MAG_COLOR + FACETED, NULL, 0);

	free((void *)x);
	free((void *)y);
	plFree2dGrid(z, XPTS, YPTS);

	plend();

	exit(0);
}

int count_digits(int arg) {
	return snprintf(NULL, 0, "%d", arg) - (arg < 0);
}

void PLOutput(const char *driver, int x_ratio, int y_ratio, const char *filename) {

	int width = (GetSystemMetrics(SM_CXSCREEN) * x_ratio) / 100;
	int height = (GetSystemMetrics(SM_CYSCREEN) * y_ratio) / 100;

	char *buf = new char[count_digits(width) + count_digits(height) + 2];
	SecureZeroMemory(buf, count_digits(width) + count_digits(height) + 2);

	_itoa(width, buf, 10);
	buf[strlen(buf)] = 'x';
	_itoa(height, (buf + strlen(buf)), 10);

	plsdev(driver);

	if (!strcmp(driver, "ntk")) {
		plsetopt("geometry", buf);
	}
	else if (!strcmp(driver, "svg")) {
		plsfnam(filename);
	}

	delete[] buf;
}

static void cmap1_init(int gray) {
	PLFLT i[2], h[2], l[2], s[2];

	i[0] = 0.0;         // left boundary
	i[1] = 1.0;         // right boundary

	if (gray)
	{
		h[0] = 0.0;     // hue -- low: red (arbitrary if s=0)
		h[1] = 0.0;     // hue -- high: red (arbitrary if s=0)

		l[0] = 0.5;     // lightness -- low: half-dark
		l[1] = 1.0;     // lightness -- high: light

		s[0] = 0.0;     // minimum saturation
		s[1] = 0.0;     // minimum saturation
	}
	else
	{
		h[0] = 240; // blue -> green -> yellow ->
		h[1] = 0;   // -> red

		l[0] = 0.6;
		l[1] = 0.6;

		s[0] = 0.8;
		s[1] = 0.8;
	}

	plscmap1n(256);
	c_plscmap1l(0, 2, i, h, l, s, NULL);
}


////////////////////////////////////////////////////


